# Constant Time O(1)
* No matter how many elements we're working with, the algorithm/operation will always take the same amount of time.

# Logarithmic Time O log(n)
If doubling the number of elements you are iterating over doesn't double the amount of work. Always assumed that searching operations are log(n).

# Linear Time O(n)
Iterating through all elements in a collection of data. If you see a for loop spanning from 0 to array.length, it is probably O(n).

# Quasilinear Time O n * log(n)
If doubling the number of elements you are iterating over doesn't double the amount of work. Always assume that sorting algorithms are O n * log(n).

# Quadratic Time O(n^2)
Every element in a collection has to be compared with every other element. The handshake problem.

#Exponential Time O (2^n)
If you add a single element to a collection, the processing power required doubles. 
